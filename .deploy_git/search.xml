<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题日记2.26</title>
      <link href="/2025/02/26/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B02.26/"/>
      <url>/2025/02/26/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B02.26/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前缀和"><a href="#1-前缀和" class="headerlink" title="1.前缀和"></a>1.前缀和</h2><p>前缀和提供一个时间复杂的为O(1)的区间查询。通过前缀和右端点与左端点-1之差可以得到其区间和。</p><p>本题链接：</p><p><a href="https://www.starrycoding.com/problem/7">【模板】前缀和 | 星码StarryCoding | 算法竞赛新手村 | ACM、OI、蓝桥杯、天梯赛、CCF、ACM-ICPC、大学生信息学竞赛</a></p><p>今日题解如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> <span class="number">+9</span>;</span><br><span class="line">ll a[N], pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">   <span class="type">int</span> t;</span><br><span class="line">   cin&gt;&gt;t;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">   <span class="type">int</span> n,q;</span><br><span class="line">   cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)cin&gt;&gt;a[i];</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)pre[i] = pre[i<span class="number">-1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">   <span class="type">int</span> l, r;</span><br><span class="line">   cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">   cout &lt;&lt; pre[r] -pre[l - <span class="number">1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>粗心的把ll &#x3D; long long 写成ll &#x3D; int；导致结果错误。</p><h2 id="2-差分"><a href="#2-差分" class="headerlink" title="2.差分"></a>2.差分</h2><p>差分便于区间修改，可以通过前缀和得到前缀和数组，然后利用前缀和得到修改后的区间和。</p><p>原题链接：</p><p><a href="https://www.starrycoding.com/problem/8">【模板】差分 | 星码StarryCoding | 算法竞赛新手村 | ACM、OI、蓝桥杯、天梯赛、CCF、ACM-ICPC、大学生信息学竞赛</a></p><p>今日题解:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line">ll a[N],diff[N],pre[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,p,q;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;p&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">diff[i] = a[i] - a[i<span class="number">-1</span>];<span class="comment">//差分数组每一项为原数组两项之差</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(p--) &#123;</span><br><span class="line"><span class="type">int</span> l,r,x;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r&gt;&gt;x;</span><br><span class="line">diff[l]+=x;</span><br><span class="line">diff[r<span class="number">+1</span>]-=x;<span class="comment">//只在[l,r]上修改，之后的要恢复原样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">a[i]=a[i<span class="number">-1</span>]+diff[i];<span class="comment">//恢复成原数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line">pre[i]=pre[i<span class="number">-1</span>]+a[i];<span class="comment">//修改后的前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;pre[r] - pre[l<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-二维前缀和"><a href="#3-二维前缀和" class="headerlink" title="3.二维前缀和"></a>3.<strong>二维前缀和</strong></h2><p>原题链接：</p><p><a href="https://www.starrycoding.com/problem/15">【模板】二维前缀和 | 星码StarryCoding | 算法竞赛新手村 | ACM、OI、蓝桥杯、天梯赛、CCF、ACM-ICPC、大学生信息学竞赛</a></p><p>今日题解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">9</span>;</span><br><span class="line">ll a[N][N], pre[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> n,m,q;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j) &#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;++j) &#123;</span><br><span class="line">pre[i][j]=pre[i<span class="number">-1</span>][j]+pre[i][j<span class="number">-1</span>]-pre[i<span class="number">-1</span>][j<span class="number">-1</span>]+a[i][j];<span class="comment">//见图1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q--) &#123;</span><br><span class="line"><span class="type">int</span> x1,y1,x2,y2;</span><br><span class="line">cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</span><br><span class="line">cout&lt;&lt;pre[x2][y2]-pre[x2][y1<span class="number">-1</span>]-pre[x1<span class="number">-1</span>][y2]+pre[x1<span class="number">-1</span>][y1<span class="number">-1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;<span class="comment">//见图2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cin&gt;&gt;t;</span></span><br><span class="line"><span class="keyword">while</span>(t--) &#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图1：</p><p><img src="/2025/02/26/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B02.26/image-20250226225152860.png" alt="image-20250226225152860"></p><p>图2：</p><p><img src="/2025/02/26/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B02.26/image-20250226225220869.png" alt="image-20250226225220869"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/02/24/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2025/02/24/%E5%88%B7%E9%A2%98%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p><strong>1.scanf和printf</strong></p><p>用于格式化输入输出</p><p>不能取消同步流</p><p><strong>2.cin和cout（c++特性</strong>）</p><p>简洁，在取消同步流的情况下一般比scanf更快</p><p>取消同步流一定要写完整</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>一般不要使用cout &lt;&lt; endl;改用cout &lt;&lt; ‘\n’;</p><p>endl&#x3D;’\n’+强制刷新缓冲区（比较慢而且一般也不需要）</p><p><strong>3.输入就单独的输入，一会输入做io,一会做计算反而慢一点。</strong></p><p>4.定义时一般使用using type xx &#x3D; xxx;而不是#define xx xxx;前者为一个变量，后者为整体带入，如果没括号可能会导致计算错误。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>编译原理</title>
      <link href="/2025/02/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/2025/02/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h2><h3 id="编译程序的工作过程："><a href="#编译程序的工作过程：" class="headerlink" title="编译程序的工作过程："></a><strong>编译程序的工作过程：</strong></h3><p><strong>1.词法分析</strong>：扫描源程序，分解和识别出每个单词，并把单词翻译成相应的机内表示。tips：单词是语言中最小的语义单位，如语言中的关键字(保留字或基本字)、标识符、常数、运算符和界限符。</p><p><strong>2.语法分析</strong>：把单词符号串分解成各类语法单位，如表达式，语句等。判断是否正确，不正确则抛出错误位置和性质。</p><p><strong>3.语义分析</strong>：保证标识符和常数的正确使用。</p><p><strong>4.中间代码生成</strong>(非必要)：将源程序翻译成某种中间代码形式如三元式、四元式和逆波兰式等。</p><p><strong>5.中间代码优化</strong>(非必要)：调整或改变中间代码某些操作次序以产生更高效的目标代码。</p><p><strong>6.目标代码生成</strong>：将优化后的代码转换成等价的机器代码或汇编指令。</p><h3 id="编译程序结构"><a href="#编译程序结构" class="headerlink" title="编译程序结构"></a><strong>编译程序结构</strong></h3><p><img src="/2025/02/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1740148009384.jpg" alt="1740148009384"></p><h3 id="高级程序设计语言翻译的两种方式"><a href="#高级程序设计语言翻译的两种方式" class="headerlink" title="高级程序设计语言翻译的两种方式"></a>高级程序设计语言翻译的两种方式</h3><p>1.编译方式是指在程序运行之前，将高级语言程序完整地翻译成机器语言程序或中间代码。编译器（Compiler）是实现这一过程的软件工具。</p><p>2.解释方式是指在程序运行时，逐条读取高级语言程序并翻译执行。解释器（Interpreter）是实现这一过程的软件工具。</p><p><img src="/2025/02/21/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/image-20250221230151097.png" alt="image-20250221230151097"></p><h3 id="编译程序的自展"><a href="#编译程序的自展" class="headerlink" title="编译程序的自展"></a>编译程序的自展</h3><ol><li><strong>定义</strong>：自展是指使用已有的编译器来编译自身的源代码，从而生成新的编译器。例如，C语言的编译器可以用C语言本身编写，然后用现有的C编译器来编译它，生成新的编译器。</li><li><strong>过程</strong>：自展通常是一个迭代过程。例如，先用语言X1编写语言X2的编译器，然后用X2编写X3的编译器，依此类推。这种方法可以逐步扩展编译器的功能和语言的特性。</li><li><strong>优点</strong>：自展可以保证编译器的正确性和可靠性，并且能够逐步优化编译器的性能。</li></ol><h3 id="编译程序的移植"><a href="#编译程序的移植" class="headerlink" title="编译程序的移植"></a>编译程序的移植</h3><ol><li><strong>定义</strong>：移植是指将已有的编译器从一个平台迁移到另一个平台上运行。这可能涉及到对编译器代码的修改和适配。</li><li><strong>方法</strong>：移植通常需要对目标平台的特性（如指令集、操作系统等）进行适配。例如，将一个在x86架构上运行的编译器移植到ARM架构上。</li><li><strong>挑战</strong>：移植过程中可能需要解决不同平台之间的差异，如字节序、数据对齐等问题。</li></ol><h3 id="编译程序的自动化"><a href="#编译程序的自动化" class="headerlink" title="编译程序的自动化"></a>编译程序的自动化</h3><p><strong>定义</strong>：编译程序的自动化是指使用专门的工具或脚本，根据给定的规则和描述文件自动生成编译程序。例如，Make工具可以根据Makefile中的规则自动化构建项目。</p><h3 id="并行编译的概念"><a href="#并行编译的概念" class="headerlink" title="并行编译的概念"></a>并行编译的概念</h3><ol><li><strong>定义</strong>：并行编译是指将编译过程中的多个独立任务分配给多个处理器或计算节点同时执行，从而缩短整体编译时间。</li><li><strong>原理</strong>：编译过程可以分为多个独立的任务（如编译不同的源文件），这些任务之间没有依赖关系，可以并行执行。</li></ol><h2 id="形式语言理论"><a href="#形式语言理论" class="headerlink" title="形式语言理论"></a>形式语言理论</h2><p>形式语言理论研究语言的结构、语法、语义以及语言的生成和识别机制。</p><hr><h3 id="1-形式语言的定义"><a href="#1-形式语言的定义" class="headerlink" title="1. 形式语言的定义"></a>1. <strong>形式语言的定义</strong></h3><p>形式语言是一种由符号组成的集合，这些符号按照一定的规则（语法）组合成字符串。形式语言的定义通常包括以下几个要素：</p><ul><li><strong>字母表（Alphabet）</strong>：一个有限的符号集合，通常用Σ（Sigma）表示。例如，Σ &#x3D; {a, b}。</li><li><strong>字符串（String）</strong>：由字母表中的符号组成的有限序列。例如，对于Σ &#x3D; {a, b}，字符串可以是“ab”、“bbaa”等。</li><li><strong>语言（Language）</strong>：由字母表上的所有字符串构成的集合。形式语言可以被定义为从字母表生成的字符串的集合。</li></ul><hr><h3 id="2-形式文法（Formal-Grammar）"><a href="#2-形式文法（Formal-Grammar）" class="headerlink" title="2. 形式文法（Formal Grammar）"></a>2. <strong>形式文法（Formal Grammar）</strong></h3><p>形式文法是用于生成形式语言的规则系统。它定义了如何从基本符号组合成复杂的字符串。形式文法通常由以下四部分组成：</p><ol><li><strong>非终结符（Non-terminals）</strong>：用于表示尚未生成的符号，通常用大写字母表示，如S、A、B等。</li><li><strong>终结符（Terminals）</strong>：最终生成的符号，通常用小写字母表示，如a、b等。</li><li><strong>产生式规则（Production Rules）</strong>：定义了如何将非终结符替换为其他符号的规则。例如，<code>S → aSb</code>。</li><li><strong>起始符号（Start Symbol）</strong>：一个特殊的非终结符，表示生成过程的起点。</li></ol><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><p>一个简单的文法：</p><ul><li>非终结符：S</li><li>终结符：a, b</li><li>产生式规则：<ul><li><code>S → aSb</code></li><li><code>S → ε</code>（ε表示空字符串）</li></ul></li><li>起始符号：S</li></ul><p>这个文法可以生成所有形如<code>a^n b^n</code>（n≥0）的字符串，例如<code>&quot;&quot;</code>、<code>&quot;ab&quot;</code>、<code>&quot;aabb&quot;</code>等。</p><h3 id="乔姆斯基文法层次的四个类型及其特点："><a href="#乔姆斯基文法层次的四个类型及其特点：" class="headerlink" title="乔姆斯基文法层次的四个类型及其特点："></a>乔姆斯基文法层次的四个类型及其特点：</h3><hr><ol><li><strong>0型文法（无限制文法，Type-0 Grammar）</strong></li></ol><ul><li><strong>定义</strong>：产生式规则的形式为<code>α → β</code>，其中<code>α</code>和<code>β</code>是字母表上的符号序列，且<code>α</code>中至少包含一个非终结符。</li><li><strong>特点</strong>：<ul><li>产生式规则没有任何限制。</li><li>可以生成非常复杂的语言，包括递归可枚举语言（Recursively Enumerable Languages）。</li></ul></li><li><strong>对应的自动机</strong>：图灵机（Turing Machine）。</li><li><strong>应用场景</strong>：图灵机是计算模型的理论基础，用于研究可计算性问题。</li></ul><hr><ol start="2"><li><strong>1型文法（上下文有关文法，Type-1 Grammar）</strong></li></ol><ul><li><strong>定义</strong>：产生式规则的形式为<code>αAβ → αγβ</code>，其中<code>A</code>是非终结符，<code>α</code>、<code>β</code>和<code>γ</code>是符号序列，且<code>γ</code>不能为空。</li><li><strong>特点</strong>：<ul><li>非终结符的替换依赖于上下文（即<code>α</code>和<code>β</code>）。</li><li>生成的语言称为上下文有关语言（Context-Sensitive Languages）。</li><li>语言的复杂性介于上下文无关语言和递归可枚举语言之间。</li></ul></li><li><strong>对应的自动机</strong>：线性有界自动机（Linear Bounded Automata, LBA）。</li><li><strong>应用场景</strong>：主要用于理论研究，实际应用较少。</li></ul><hr><ol start="3"><li><strong>2型文法（上下文无关文法，Type-2 Grammar）</strong></li></ol><ul><li><strong>定义</strong>：产生式规则的形式为<code>A → α</code>，其中<code>A</code>是非终结符，<code>α</code>是符号序列（可以包含终结符和非终结符）。</li><li><strong>特点</strong>：<ul><li>非终结符的替换不依赖于上下文。</li><li>生成的语言称为上下文无关语言（Context-Free Languages）。</li><li>语言的复杂性较低，适合描述程序设计语言的语法结构。</li></ul></li><li><strong>对应的自动机</strong>：下推自动机（Pushdown Automata, PDA）。</li><li><strong>应用场景</strong>：广泛用于编译器设计中的语法分析，例如LL(1)解析器、LR解析器等。</li></ul><hr><ol start="4"><li><strong>3型文法（正则文法，Type-3 Grammar）</strong></li></ol><ul><li><strong>定义</strong>：产生式规则的形式为<code>A → aB</code>或<code>A → a</code>，其中<code>A</code>和<code>B</code>是非终结符，<code>a</code>是终结符。<ul><li>也可以写成<code>A → a</code>或<code>A → aB</code>的形式（右线性文法）。</li></ul></li><li><strong>特点</strong>：<ul><li>生成的语言称为正则语言（Regular Languages）。</li><li>语言的复杂性最低，适合描述简单的模式匹配。</li></ul></li><li><strong>对应的自动机</strong>：有限状态自动机（Finite Automata, FA），包括确定性有限自动机（DFA）和非确定性有限自动机（NFA）。</li><li><strong>应用场景</strong>：广泛用于词法分析器的设计，例如正则表达式匹配。</li></ul><h4 id="乔姆斯基文法层次的总结"><a href="#乔姆斯基文法层次的总结" class="headerlink" title="乔姆斯基文法层次的总结"></a>乔姆斯基文法层次的总结</h4><table><thead><tr><th align="left">类型</th><th align="left">特点</th><th align="left">产生式规则</th><th align="left">语言类别</th><th align="left">对应的自动机</th></tr></thead><tbody><tr><td align="left">0型文法</td><td align="left">无限制</td><td align="left"><code>α → β</code>（<code>α</code>中至少包含一个非终结符）</td><td align="left">递归可枚举语言</td><td align="left">图灵机</td></tr><tr><td align="left">1型文法</td><td align="left">上下文有关</td><td align="left"><code>αAβ → αγβ</code>（<code>γ</code>不能为空）</td><td align="left">上下文有关语言</td><td align="left">线性有界自动机</td></tr><tr><td align="left">2型文法</td><td align="left">上下文无关</td><td align="left"><code>A → α</code></td><td align="left">上下文无关语言</td><td align="left">下推自动机</td></tr><tr><td align="left">3型文法</td><td align="left">正则</td><td align="left"><code>A → aB</code> 或 <code>A → a</code></td><td align="left">正则语言</td><td align="left">有限状态自动机</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机科学学习记录</title>
      <link href="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>逻辑门的实现</strong></p><p>NOT:<img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219192653645.png" alt="image-20250219192653645"></p><p>AND:</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219192740802.png" alt="image-20250219192740802"></p><p>OR:</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219192840808.png" alt="image-20250219192840808"></p><p>XOR:</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219192931677.png" alt="image-20250219192931677"></p><p><strong>算术逻辑单元(ALU)</strong></p><p>半加器(处理1+1以内的运算)</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219195726811.png" alt="image-20250219195726811"></p><p>全加器(处理1+1+1以内的运算)</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219200002098.png" alt="image-20250219200002098"></p><p>锁存器:</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219203435390.png"></p><p>门锁：</p><p><img src="/2025/02/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AE%B0%E5%BD%95/image-20250219203513305.png" alt="image-20250219203513305"></p><p>矩阵排列门锁构成寄存器。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统概述"><a href="#操作系统概述" class="headerlink" title="操作系统概述"></a>操作系统概述</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>操作系统(Operating System;OS)是<strong>计算机硬件与用户之间的接口</strong>(系统软件程序)，它管理和调度硬件资源（如CPU、内存、输入&#x2F;输出设备等），并提供用户与计算机交互的界面。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>最基本特征为<strong>并发</strong>和<strong>共享</strong>(二者互为存在条件)</p><p><strong>并发</strong>：是指两个或多个活动在同一给定的时间段中进行</p><p><strong>共享</strong>：是指计算机系统中的资源被多个进程所共用</p><p><strong>异步</strong>：进程以不可预知的速度向前推进</p><p><strong>虚拟</strong>：把一个物理上的实体变为若干个逻辑上的对应物</p><p>关于并发和并行的区别：可以想象并发是有两排队伍排一个窗口，而并行是两个队伍分别排两个窗口。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>1.计算机资源管理：</strong></p><p><strong>处理器管理</strong>:主要包括进程控制、进程同步、进程通信、死锁处理、处理器调度等</p><p><strong>存储器管理</strong>:主要包括内存分配与回收、地址映射、内存保护与共享、内存扩充等</p><p><strong>文件管理</strong>:主要包括文件存储空间的管理、目录管理、文件读写管理和保护等</p><p><strong>设备管理</strong>:主要包括缓冲管理、设备分配、设备处理、虚拟设备等</p><p>2.<strong>作为用户与计算机硬件系统之间的接口</strong>：<strong>命令接口和程序接口</strong></p><p>3.<strong>用作扩充机器</strong>。</p><h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><ul><li>特权指令：不允许用户程序使用(只允许操作系统使用)如IO指令、中断指令。</li><li>非特权指令：普通的运算指令</li><li>内核程序：系统的管理者，可以执行一切指令，运行在核心态</li><li>应用程序：普通用户程序只能执行非特权程序，运行在用户态</li></ul><p><strong>处理器状态：</strong></p><ul><li>用户态(目态)：CPU只能执行非特权指令</li><li>核心态(管态、内核态)：可以执行所有指令</li><li>用户态到内核态：通过中断或异常**(是硬件完成的)**</li><li>核心态到用户态：特权指令psw的标志位，0用户态，1核心态。</li></ul><p><strong>原语：</strong></p><ul><li>处在操作系统的最底层，是最接近硬件的部分</li><li>这些程序的运行具有原子性，其操作只能一气呵成</li><li>这些程序的运行时间都较短，而且调用频繁</li></ul><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程（Process）"><a href="#进程（Process）" class="headerlink" title="进程（Process）"></a><strong>进程（Process）</strong></h3><p>进程是<strong>操作系统进行资源分配和调度的基本单位</strong>，是<strong>程序在处理器上的一次运行活动</strong>。进程包括程序控制块、PCB、程序段、数据段。</p><p>PCB：包含操作系统对其进行管理所需的各种信息，如进程描述信息、控制信息、管理信息、资源分配清单和处理器相关信息</p><p><strong>特点：</strong></p><ul><li><strong>动态性(基本特征)</strong>：进程是动态的实体，有创建、运行、阻塞、终止等状态。</li><li><strong>并发性</strong>：多个进程可以同时运行，共享系统资源。</li><li><strong>独立性</strong>：<strong>进程是资源分配的基本单位</strong>，具有独立的资源和运行环境。</li><li>异步性：各个进程按各自独立的、不可预知的速度向前推进，操作系统要提供进程同步机制来解决异步问题。</li><li>结构性：每个进程都配置一个PCB。结构上看，进程由程序段、数据段和PCB组成。</li></ul><p><strong>进程状态：</strong></p><ul><li><strong>就绪态（Ready）</strong>：进程已准备好运行，等待CPU分配。</li><li><strong>运行态（Running）</strong>：进程正在CPU上运行。</li><li><strong>阻塞态（Blocked）</strong>：进程因等待某种事件（如I&#x2F;O操作完成）而暂停运行。</li></ul><p>进程的状态转换：</p><p><img src="/2025/02/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20250218154211332.png"></p><p><strong>线程（Thread）</strong></p><p><strong>线程是进程中的一个执行单元，是CPU调度的基本单位</strong>。一个进程可以包含多个线程，它们共享进程的资源。<br><strong>特点：</strong></p><ul><li><strong>轻量级</strong>：线程的创建和切换开销小。</li><li><strong>并发性</strong>：多个线程可以并发执行，提高程序的效率。</li><li><strong>共享资源</strong>：线程共享所属进程的资源，如内存空间。</li></ul><p><strong>线程与进程的区别：</strong></p><ul><li>线程是进程的子集，线程的切换更快，但线程之间共享资源可能导致数据竞争和同步问题。</li><li>进程是资源分配的基本单位，线程是CPU调度的基本单位。</li></ul><p>CPU调度常用算法</p><ul><li><p><strong>先来先服务（FCFS，First-Come-First-Served）</strong>：按进程到达的顺序调度，简单但可能导致饥饿现象。</p></li><li><p><strong>最短作业优先（SJF，Shortest Job First）</strong>：优先调度运行时间最短的进程，但需要预估进程运行时间。</p></li><li><p><strong>优先级调度（Priority Scheduling）</strong>：根据进程的优先级进行调度，优先级高的进程优先运行。</p></li><li><p><strong>最高响应比优先（HRRN,Highest Response Ratio Next）</strong>：是一种非抢占式的动态调度算法，主要用于平衡短作业和长作业的执行需求。它通过计算每个进程的<strong>响应比</strong>来选择下一个执行的进程，响应比公式为：</p><p><strong>响应比 &#x3D; 1 + 等待时间 &#x2F; 执行时间</strong></p><ul><li><strong>特点</strong>：随着进程等待时间增加，响应比升高，避免长作业饥饿，同时兼顾短作业的快速响应。</li><li><strong>优点</strong>：兼顾公平性和效率，避免饥饿问题，适合批处理系统。</li><li><strong>缺点</strong>：计算复杂度较高，调度开销大。</li><li><strong>适用场景</strong>：适用于需要平衡长短作业的系统，提高吞吐量和响应速度。</li></ul></li><li><p><strong>时间片轮转（RR，Round-Robin）</strong>：将CPU时间划分为时间片，按顺序分配给就绪队列中的进程，适合分时系统。</p></li></ul><h3 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h3><p>1）进程通信是指进程之间的信息交换。</p><p><strong>低级通信</strong>：PV操作</p><p><strong>高级通信</strong>：是指以较高的效率传输大量数据的通信方式。</p><p>高级通信方法主要有三类：</p><p>1.共享存储：基于共享数据结构的通信方式(如生产者和消费者)基于共享存储区的通信方式。</p><p>2.消息传递：是以格式化的消息为单位，利用原语传递消息，分为直接通信和间接通信。</p><p>3.管道通信：是消息传递的一种特殊方式，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又称pipe文件。</p><p><strong>临界区</strong>：每个进程中访问临界资源(一次只允许一个进程使用的资源)的那段<strong>代码</strong>称为临界区。</p><p>进程同步机制应遵循的<strong>原则</strong>：空闲让进、忙则等待、有限等待、让权等待。</p><p>实现进程同步的<strong>机制</strong>有：</p><ul><li><strong>互斥锁（Mutex）</strong>：确保同一时间只有一个线程可以访问共享资源。</li><li><strong>信号量（Semaphore）</strong>：用于控制对共享资源的访问数量。</li><li><strong>条件变量（Condition Variable）</strong>：用于线程间的同步，等待某个条件满足后再执行。</li></ul><h4 id="PV操作解决生产者-消费者问题"><a href="#PV操作解决生产者-消费者问题" class="headerlink" title="PV操作解决生产者-消费者问题"></a>PV操作解决生产者-消费者问题</h4><p><strong>信号量定义</strong></p><ul><li><code>mutex</code>：用于保护缓冲区的互斥访问，初始值为1。</li><li><code>empty</code>：表示缓冲区中空闲位置的数量，初始值为<code>N</code>（缓冲区大小）。</li><li><code>full</code>：表示缓冲区中已占用位置的数量，初始值为0。</li></ul><p><strong>生产者伪代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥信号量</span></span><br><span class="line">semaphore empty = N;  <span class="comment">// 空位信号量，初始值为缓冲区大小</span></span><br><span class="line">semaphore full = <span class="number">0</span>;   <span class="comment">// 满位信号量，初始值为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        produce_item();  <span class="comment">// 生产一个产品</span></span><br><span class="line"><span class="comment">//消耗一个产品进入空闲缓冲区</span></span><br><span class="line">        P(empty);        <span class="comment">// 等待空位，减少空位计数</span></span><br><span class="line">        P(mutex);        <span class="comment">// 进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将产品放入缓冲区</span></span><br><span class="line">        put_item_into_buffer();</span><br><span class="line"></span><br><span class="line">        V(mutex);        <span class="comment">// 离开临界区</span></span><br><span class="line">        V(full);         <span class="comment">// 增加满位计数，通知消费者</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>消费者伪代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(full);         <span class="comment">// 等待有产品，减少满位计数</span></span><br><span class="line">        P(mutex);        <span class="comment">// 进入临界区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从缓冲区取出产品</span></span><br><span class="line">        take_item_from_buffer();</span><br><span class="line"></span><br><span class="line">        V(mutex);        <span class="comment">// 离开临界区</span></span><br><span class="line">        V(empty);        <span class="comment">// 增加空位计数，通知生产者</span></span><br><span class="line">        consume_item();  <span class="comment">// 消费产品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行示例</strong></p><p>假设缓冲区大小为<code>N</code>：</p><ul><li>初始时，<code>empty = N</code>，<code>full = 0</code>。</li><li>生产者执行<code>P(empty)</code>，<code>empty</code>减1，表示占用一个空位。</li><li>生产者执行<code>V(full)</code>，<code>full</code>加1，表示增加一个满位。</li><li>消费者执行<code>P(full)</code>，<code>full</code>减1，表示取出一个产品。</li><li>消费者执行<code>V(empty)</code>，<code>empty</code>加1，表示释放一个空位。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图片显示测试</title>
      <link href="/2025/02/04/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/02/04/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>1111<br><img src="/2025/02/04/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%B5%8B%E8%AF%95/image-20250201135214019.png" alt="示例图片" title="logo"><br><img src="/2025/02/04/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%B5%8B%E8%AF%95/logo.jpg" alt="示例图片" title="logo"><br><img src="/2025/02/04/%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA%E6%B5%8B%E8%AF%95/image.png" alt="示例图片" title="logo">  </p><p>11111</p><p>111111</p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础复盘</title>
      <link href="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/"/>
      <url>/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Java概述"><a href="#一、Java概述" class="headerlink" title="一、Java概述"></a>一、Java概述</h2><h3 id="1-Java定义"><a href="#1-Java定义" class="headerlink" title="1.Java定义"></a>1.Java定义</h3><p>由Sun公司于1995发布的一种编程语言和计算平台。</p><p>主要分为三个版本：JavaSE—标准版，JavaEE—企业版，JavaME—微型版。</p><h3 id="2-Java特点"><a href="#2-Java特点" class="headerlink" title="2.Java特点"></a>2.Java特点</h3><p>1.<strong>面向对象</strong>，即将现实世界抽象成一个一个的对象，把相关的数据和方法当作一个整体来看待。</p><p>2.<strong>静态语言</strong>。强类型语言。静态语言执行效率比动态语言高，速度更快。而动态语言能够用更少的代码实现相同的功能，程序员编码效率高。</p><p>3.**跨平台和可移植性。**已编译的Java程序依靠JVM实现在不同平台能够直接运行。</p><p>4.<strong>容易实现多线程</strong>。在用户空间中实现多线程。</p><p>5.<strong>高性能</strong>。不仅支持解释执行，有些JVM(Hotspot JVM)还支持编译执行。</p><p>6.<strong>自动管理对象的生命周期</strong>。安全。</p><p>7.功能强大和简单易用。</p><h2 id="二、Java开发环境"><a href="#二、Java开发环境" class="headerlink" title="二、Java开发环境"></a>二、Java开发环境</h2><p>JDK包括jre和核心类库。jre包括jvm。</p><p>jre是java运行环境，如果只是需要运行普通的java程序，只要安装jre即可。</p><h2 id="三、Java基础语法"><a href="#三、Java基础语法" class="headerlink" title="三、Java基础语法"></a>三、Java基础语法</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><p>四类八种：</p><p>1.整数型：<br>byte一个字节即8位(-128-127)，<br>short两个字节即16位(-32768-32767)，<br>int4个字节即32位(-2147283648-2147483647)，<br>long八个字节即64位(-9e18-9e18)—后加L</p><p>2.浮点型：<br>float4字节即32位—精确到到小数点后六位—后加f，<br>double8字节即64位精确到小数点后15位—后加d。</p><p>3.字符型：<br>char类型是一个单一的16位Unicode字符，最小值(\u0000)也就是0，最大值\uffff即65535。</p><p>4.布尔型Boolean类型：只有true或false。</p><h3 id="2-基础语法"><a href="#2-基础语法" class="headerlink" title="2.基础语法"></a>2.基础语法</h3><p>1.大小写敏感</p><p>2.类名采用大驼峰命名法(即MyClass类似的)</p><p>3.包名小写(网址倒序)</p><p>4方法名采用小驼峰命名法(即myFirstMethod类似的)</p><h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h3><p>1.<strong>赋值运算符’&#x3D;‘</strong>，一般来说右值赋值给明确变量类型的左值就行。但是对象的赋值一般来说其实赋的是对象的引用，当一个对象的引用被赋值给另一个引用变量时，两个引用变量指向同一个对象。当然对象的赋值还有其他方式：</p><ul><li><p><strong>浅拷贝</strong>：复制对象的字段值，但引用类型的字段仍然指向同一个对象。</p></li><li><p><strong>深拷贝</strong>：递归复制对象及其引用类型的字段所指向的对象，创建一个完全独立的对象。</p></li></ul><p>2.自增自减运算符：</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250201135214019.png"></p><p>3.算数运算符与比较运算符和数学差不多</p><p>4.逻辑运算符与数学差不多，按位运算符比较的是二进制位</p><p>5.移位运算符是将某个操作数向某个方向移动指定的二进制位数例如：</p><p>​8&gt;&gt;1&#x3D;4;9&lt;&lt;2&#x3D;36;</p><p>6.三元运算符：语法为：</p><p>​<strong>条件表达式？表达式1：表达式2</strong></p><p>条件表达式为true就调用表达式1，否则调用表达式2.</p><h2 id="四、Java执行流程控制"><a href="#四、Java执行流程控制" class="headerlink" title="四、Java执行流程控制"></a>四、Java执行流程控制</h2><h3 id="1-条件语句"><a href="#1-条件语句" class="headerlink" title="1.条件语句"></a>1.条件语句</h3><p>1.if…else</p><p><code>if(表达式) &#123;</code></p><p>​<code>表达式为真执行；</code></p><p><code>&#125;</code></p><p><code>else &#123;</code></p><p>​<code>否则执行</code></p><p><code>&#125;</code></p><p>2.switch用于小范围单个值</p><p><code>switch(变量) &#123;</code></p><p>​<code>case 值1：</code></p><p>​<code>表达式1；</code></p><p>​<code>break；</code></p><p>​<code>case 值2：</code></p><p>​<code>表达式2：</code></p><p>​<code>break；</code></p><p>​<code>......</code></p><p>​<code>default：</code></p><p>​<code>表达式n;</code></p><p>​<code>break;</code></p><p><code>&#125;</code></p><p>注意：不要忘记加每个case的表达式后加上break，否则会发生**“穿透”(fall-through)**现象。这意味着程序会从匹配的<code>case</code>开始执行，直到遇到<code>break</code>语句或<code>switch</code>块的末尾为止，而不会自动停止。</p><h3 id="2-循环语句"><a href="#2-循环语句" class="headerlink" title="2.循环语句"></a>2.循环语句</h3><p>while，do…while，for和for-each</p><p>while(表达式) {</p><p>​为真执行并再次调用while()；</p><p>}</p><p>do {</p><p>​第一次直接执行，后续满足表达式执行；</p><p>}while(表达式)；</p><p>for( 初始化;条件 ;步进 ) { 条件为真执行}</p><p>for-each例如:</p><p>​int array[]&#x3D;{1,2,3}</p><p>​for(auto arr: array) {</p><p>​System.out.println(arr);</p><p>​}</p><p>打印数组。</p><h3 id="3-跳转语句"><a href="#3-跳转语句" class="headerlink" title="3.跳转语句"></a>3.跳转语句</h3><p>有break，continue和return</p><p>break用于退出当前循环</p><p>continue用于退出当次循环进入下一次循环</p><p>return直接结束本次函数调用</p><h2 id="五、面向对象"><a href="#五、面向对象" class="headerlink" title="五、面向对象"></a>五、面向对象</h2><h3 id="1-类和对象"><a href="#1-类和对象" class="headerlink" title="1.类和对象"></a>1.类和对象</h3><p>类是对象的模板，有属性和方法，对象是类的具体体现，可以操作属性和方法。</p><h3 id="2-对象的创建"><a href="#2-对象的创建" class="headerlink" title="2.对象的创建"></a>2.对象的创建</h3><p>1.在java中万事万物皆对象，但是我们操纵的确是一个个对象的引用(reference)。这个引用可以独立存在如：</p><p><code>Car carKey；</code></p><p>但是我们一般在创建对象引用时会同时把一个对象赋给它如：</p><p><code>Car carKey = new Car();</code></p><h3 id="3-属性和方法"><a href="#3-属性和方法" class="headerlink" title="3.属性和方法"></a>3.属性和方法</h3><p>属性也被称为字段，属性可以是对象，也可以是基本数据类型。</p><p>方法也就是函数，意思是做某些事情。</p><p>方法的示例：</p><p>访问修饰符(public等)(其他修饰符static等)返回值类型 方法名称(参数列表){</p><p>​方法体;</p><p>} </p><p>如果没有指定修饰符默认同包访问权限(package-private)；</p><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="(1)构造方法"></a>(1)构造方法</h4><p>构造方法也称构造器，构造函数，它是一种特殊的方法。</p><p>特点：</p><p>1.用于在创建对象的时候初始化对象，给对象的字段赋初始值。</p><p>2.它的方法名称必须和类名相同，</p><p>3.没有返回值类型(连void都没有)。</p><p>4.如果定义类的时候没有定义构造方法，Java编译器会自动提供一个无参构造方法，将所有字段初始化为默认值。</p><p>5.可以重载，只要参数列表不同。</p><p>6.自动调用，在使用new关键字创建对象时，Java自动调用相应的构造方法来初始化对象。</p><p>7.构造方法不能被继承或重写，但可以通过<code>super()</code>调用父类的构造方法。</p><h4 id="2-方法重载"><a href="#2-方法重载" class="headerlink" title="(2)方法重载"></a>(2)方法重载</h4><p>方法重载是一种允许类中出现多个同名方法的技术，这些方法的参数列表必须不同。具体调用哪个方法取决于传递的参数类型和数量。</p><h4 id="3-方法的重写"><a href="#3-方法的重写" class="headerlink" title="(3)方法的重写"></a>(3)方法的重写</h4><p>方法重写是一种面向对象编程中的多态特性，允许子类提供一个与父类同名且参数列表相同的实例方法。通过方法重写，子类可以覆盖父类的方法实现，从而提供自己的行为逻辑。</p><p>要实现方法重写，必须满足以下条件：</p><ol><li><strong>继承关系</strong>：子类必须继承父类。</li><li><strong>方法名和参数列表相同</strong>：子类中的方法必须与父类中的方法具有相同的名称和参数列表。</li><li><strong>返回值类型相同或兼容</strong>：子类方法的返回值类型必须与父类方法的返回值类型相同，或者返回值类型是父类返回值类型的子类(协变返回类型)。</li><li><strong>访问修饰符的限制</strong>：子类方法的访问修饰符不能比父类方法的访问修饰符更严格。例如，如果父类方法是<code>public</code>，子类方法不能是<code>protected</code>或<code>private</code>。</li><li><strong>异常声明的限制</strong>：子类方法声明的异常不能比父类方法声明的异常更宽泛。子类方法可以声明父类方法声明的异常，或者声明父类方法声明异常的子类，或者不声明异常。</li></ol><h3 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4.初始化"></a>4.初始化</h3><p>在Java中，初始化是一个重要的概念，它涉及到类、成员变量、构造器、数组等的初始化过程。以下是详细的解释：</p><h4 id="1-类的初始化"><a href="#1-类的初始化" class="headerlink" title="(1) 类的初始化"></a>(1) 类的初始化</h4><p>类的初始化是指在类加载到JVM(Java虚拟机)后，首次主动使用该类时，对其进行初始化的过程。类的初始化主要包括以下步骤：</p><ul><li><strong>加载</strong>：将类的<code>.class</code>文件加载到JVM内存中。</li><li><strong>连接</strong>：<ul><li><strong>验证</strong>：检查类的结构是否正确，是否符合Java规范。</li><li><strong>准备</strong>：为类的静态变量分配内存，并设置默认初始值。</li><li><strong>解析</strong>：将类、接口、字段和方法的符号引用转换为直接引用。</li></ul></li><li><strong>初始化</strong>：执行类构造器<code>&lt;clinit&gt;</code>方法，完成静态变量的赋值和静态代码块的执行。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(MyClass.staticVar); <span class="comment">// 触发类的初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">静态代码块执行</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="2-成员初始化"><a href="#2-成员初始化" class="headerlink" title="(2) 成员初始化"></a>(2) 成员初始化</h4><p>成员初始化是指对类的成员变量(包括实例变量和静态变量)进行初始化。成员变量的初始化方式有以下几种：</p><ul><li><strong>默认初始化</strong>：由JVM自动为成员变量赋予默认值。例如，<code>int</code>类型默认为<code>0</code>，<code>double</code>类型默认为<code>0.0</code>，<code>boolean</code>类型默认为<code>false</code>，对象引用类型默认为<code>null</code>。</li><li><strong>显式初始化</strong>：在成员变量声明时直接赋值。</li><li><strong>构造器初始化</strong>：通过构造器为成员变量赋值。</li></ul><p><strong>示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 显式初始化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 显式初始化</span></span><br><span class="line">    <span class="type">int</span> anotherVar; <span class="comment">// 默认初始化为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-构造器初始化"><a href="#3-构造器初始化" class="headerlink" title="(3) 构造器初始化"></a>(3) 构造器初始化</h4><p>构造器初始化是指通过构造器为对象的成员变量赋值。构造器是类的特殊方法，用于创建对象时初始化对象的状态。</p><p><strong>示例</strong>：</p><p>java复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> instanceVar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        instanceVar = value; <span class="comment">// 构造器初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(<span class="number">100</span>);</span><br><span class="line">        System.out.println(obj.instanceVar); <span class="comment">// 输出100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-数组初始化"><a href="#4-数组初始化" class="headerlink" title="(4) 数组初始化"></a>(4) 数组初始化</h4><p>数组初始化是指为数组分配内存并为数组元素赋值。数组初始化有以下两种方式：</p><ul><li><strong>静态初始化</strong>：在声明数组时直接指定数组元素的值。</li><li><strong>动态初始化</strong>：指定数组的长度，由JVM自动为数组元素赋予默认值。</li></ul><p><strong>示例</strong>：</p><p>java复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态初始化</span></span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>]; <span class="comment">// 默认初始化为0</span></span><br></pre></td></tr></table></figure><h4 id="5-初始化顺序"><a href="#5-初始化顺序" class="headerlink" title="(5) 初始化顺序"></a>(5) 初始化顺序</h4><p>Java中对象的初始化顺序如下：</p><ol><li><strong>加载类</strong>：加载类的<code>.class</code>文件。</li><li><strong>静态变量和静态方法块初始化</strong>：按照代码的顺序，先初始化静态变量，再执行静态代码块。</li><li><strong>实例变量初始化</strong>：按照代码的顺序，先初始化实例变量，再执行实例代码块。</li><li><strong>构造器初始化</strong>：执行构造器，为对象的成员变量赋值。</li></ol><p><strong>示例</strong>：</p><p>java复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">staticVar</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 静态变量初始化</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;实例代码块1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">instanceVar</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 实例变量初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClass</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyClass</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">静态代码块1</span><br><span class="line">静态代码块2</span><br><span class="line">实例代码块1</span><br><span class="line">构造器</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>类初始化</strong>：加载类、静态变量初始化和执行静态代码块。</li><li><strong>成员初始化</strong>：包括默认初始化、显式初始化和构造器初始化。</li><li><strong>构造器初始化</strong>：通过构造器为对象的成员变量赋值。</li><li><strong>数组初始化</strong>：静态初始化和动态初始化。</li><li><strong>初始化顺序</strong>：静态变量和静态代码块 → 实例变量和实例代码块 → 构造器。</li></ul><h3 id="5-对象的销毁"><a href="#5-对象的销毁" class="headerlink" title="5.对象的销毁"></a>5.对象的销毁</h3><p>Java和c&#x2F;c++的一个重要的特征就是不需要手动管理对象的销毁工作。对象是由<strong>Java虚拟机</strong>进行管理和销毁的。我们无需手动管理对象，但是得知道对象作用域的概念。</p><h4 id="1-对象作用域"><a href="#1-对象作用域" class="headerlink" title="(1)对象作用域"></a>(1)对象作用域</h4><p>绝大多数语言都有作用域(scope)的概念，作用域决定了对象内部定义的变量名的可见性和生命周期。java中作用域通常由{}的位置决定。</p><p><code>&#123;</code></p><p>​<code>int a = 11;</code></p><p>​<code>&#123;</code></p><p>​<code>int b = 22;</code></p><p>​<code>&#125;</code></p><p><code>&#125;</code></p><p>变量a会在两个{}中生效，而变量b只在自己的{}内生效。</p><h4 id="2-this和super"><a href="#2-this和super" class="headerlink" title="(2)this和super"></a>(2)this和super</h4><p>二者都是关键字。</p><p><strong>this</strong>作用在对象中并且不可以对静态变量或方法使用，它可以调用方法，调用属性和指向对象本身，因为局部变量优先级大于全局变量，所以在调用对象的方法进行属性的赋值时，需要使用到this来设置此对象的属性。</p><p>调用对象：例子中eatApple()方法可以调用多次，return this的返回值使得哪个对象调用这个方法都能返回对象自身。<img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250207203153099.png"></p><p>this用在构造方法时this(参数)需要放在第一行，否则编译不通过。</p><p><strong>super</strong>可以调用父类的方法，属性，指向父类。其他同this。</p><h2 id="六、访问控制权限"><a href="#六、访问控制权限" class="headerlink" title="六、访问控制权限"></a>六、访问控制权限</h2><p>访问控制权限又称封装，它是面向对象三大特性的一个，其核心是只对需要的类可见。</p><p>Java中成员的访问权限一共有四种，分别是public，protected，default，private。如下</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250207211115238.png" alt="image-20250207211115238"></p><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>三大特性之一，它是所有面向对象编程语言都不可或缺的一部分。只要我们创建了一个类，就隐式的继承自Object父类，只不过没有指定。如果显式指定了父类，那么此类的父类就继承于Object类。</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250207212537344.png" alt="image-20250207212537344"></p><p>继承的关键字是<strong>extends</strong>，如果使用了extends显式指定了继承，那么我们可以说Father是父类，而Son是子类。用代码表示如下：</p><p><code>class Father&#123;&#125;</code></p><p><code>class Son extends Father&#123;&#125;</code></p><p>子类具有父类的某些特征，如果子类没有自己的方法的话，默认调用父类的方法。如果子类实现了自己的方法，那么就相当于重写了父类的方法。</p><h3 id="2-多态"><a href="#2-多态" class="headerlink" title="2.多态"></a>2.多态</h3><p>三大特性之一，多态是指同一个行为具有不同表现形式。即一个类实例(对象)的相同方法在不同情形下具有不同表现形式。封装和继承是多态的基础，多态只是一种表现形式。</p><p>如何实现多态？达成三个充要条件：</p><ul><li>继承</li><li>重写父类方法</li><li>父类引用指向子类对象</li></ul><p>比如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat Fruit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pear</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.num = <span class="number">10</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat&quot;</span>+num+<span class="string">&quot;Pear&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuoTai</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Fruit</span> <span class="variable">fruit</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pear</span>();</span><br><span class="line">        fruit.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现main方法中Fruit fruit &#x3D; new Pear()，Fruit类型的对象竟然指向了Pear对象的引用，这其实就是多态-&gt;父类引用指向子类对象，因为Pear继承于Fruit，并且重写了eat方法，所以能够表现出来多种状态的形式。</p><h3 id="3-组合"><a href="#3-组合" class="headerlink" title="3.组合"></a>3.组合</h3><p>组合就是将对象引用置于新类中即可。组合也是一种提高类的复用性的一种方式。如果想要类具有更多的扩展功能，可以记住一句话<strong>多用组合，少用继承</strong>。二者关系如下：</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250207222214122.png" alt="image-20250207222214122"></p><h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><p>为什么需要代理：代理可以无侵入式的给对象增加其他功能。</p><p>代理大致描述为：A想要调用B类的方法，但是不直接调用而是在自己的类中创建一个B对象的代理，再由代理调用B的方法。如下图所示：</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250220105056954.png" alt="image-20250220105056954"></p><p>java如何保证代理的实现？通过接口保证，后面的对象和代理需要实现同一个接口，接口中就是被代理的所有方法。</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250223201954533.png"></p><p><strong>定义一个接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现该接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建一个<code>InvocationHandler</code>实现类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object target; <span class="comment">// 被代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在方法调用之前执行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before calling: &quot;</span> + method.getName());</span><br><span class="line">        <span class="comment">// 调用原始方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">// 在方法调用之后执行的操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After calling: &quot;</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用<code>Proxy</code>生成代理对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkProxyDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建目标对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloServiceImpl</span>();</span><br><span class="line">        <span class="comment">// 创建InvocationHandler实例</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(target);</span><br><span class="line">        <span class="comment">// 生成代理对象</span></span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">proxy</span> <span class="operator">=</span> (HelloService) Proxy.newProxyInstance(</span><br><span class="line">                HelloService.class.getClassLoader(), <span class="comment">// 目标类的类加载器</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;HelloService.class&#125;, <span class="comment">// 目标类实现的接口</span></span><br><span class="line">                handler <span class="comment">// InvocationHandler</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">// 调用代理对象的方法</span></span><br><span class="line">        proxy.sayHello(<span class="string">&quot;Kimi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Before calling: sayHello</span><br><span class="line">Hello, Kimi!</span><br><span class="line">After calling: sayHello</span><br></pre></td></tr></table></figure><h3 id="5-向上转型"><a href="#5-向上转型" class="headerlink" title="5.向上转型"></a>5.向上转型</h3><p>向上转型代表了子类和父类之间的关系，其实不仅有向上转型还有向下转型。</p><p>向上转型是子类对象(小范围)转换为父类对象(大范围)，自动完成，不用强制。</p><p>向下转型相反而且不是自动完成，需要强制指定。</p><h3 id="6-statics"><a href="#6-statics" class="headerlink" title="6.statics"></a>6.statics</h3><p><code>static</code> 关键字用于表示一个成员(变量或方法)属于类本身，而不是类的某个特定实例。这意味着所有实例共享同一个静态成员。以下是 <code>static</code> 关键字的一些主要用途：</p><ul><li><strong>静态变量</strong>：定义类的全局变量，所有实例共享。</li><li><strong>静态方法</strong>：定义类级别的方法，可以直接通过类名调用，不需要创建类的实例。静态方法中不能访问类的非静态成员变量和方法。</li><li><strong>静态初始化块</strong>：用于初始化静态变量，当类被加载时执行一次。提示程序性能。</li></ul><h3 id="7-final"><a href="#7-final" class="headerlink" title="7.final"></a>7.final</h3><p><code>final</code> 关键字用于表示一个元素(变量、方法或类)是不可变的。以下是 <code>final</code> 关键字的一些主要用途：</p><ul><li><strong>最终变量</strong>：一旦被初始化，其值就不能被改变。</li><li><strong>最终方法</strong>：不能被子类重写。</li><li><strong>最终类</strong>：不能被继承，且类中的成员方法默认指定为final方法，成员变量可以根据需要设为final。</li></ul><h2 id="七、接口和抽象类"><a href="#七、接口和抽象类" class="headerlink" title="七、接口和抽象类"></a>七、接口和抽象类</h2><p>在面向对象编程中，接口(Interface)和抽象类(Abstract Class)是两种非常重要的概念，它们都用于<strong>定义规范和提供代码复用</strong>，但它们在功能、用途和语法上有很大的区别。</p><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><ol><li><strong>接口(Interface)</strong><ul><li>接口是一种特殊的类，它完全由抽象方法(没有实现的方法)和常量组成。在 Java 中，接口中的方法默认是 <code>public</code> 和 <code>abstract</code> 的，字段默认是 <code>public static final</code> 的。</li><li>接口的目的是定义一组行为规范，<strong>任何实现了该接口的类都必须实现接口中定义的所有方法</strong>。</li><li>接口可以被多个类实现，从而实现多继承的效果。</li></ul></li><li><strong>抽象类(Abstract Class)</strong><ul><li>抽象类是一种不能被实例化的类，它既可以包含抽象方法(没有具体实现的方法)，也可以包含具体方法(有实现的方法)。</li><li>抽象类的主要目的是<strong>为子类提供一个通用的模板</strong>，<strong>子类必须实现抽象类中的所有抽象方法</strong>。</li><li>抽象类只能被单个类继承，不能实现多继承。</li></ul></li></ol><h3 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h3><ol><li><strong>方法实现</strong><ul><li><strong>接口</strong>：接口中的方法默认是抽象的，不能有具体实现。从 Java 8 开始，接口可以包含默认方法(<code>default</code>)和静态方法(<code>static</code>)，但这些方法的使用场景相对有限。</li><li><strong>抽象类</strong>：抽象类可以包含抽象方法和具体方法。抽象方法需要子类实现，具体方法可以直接被子类继承和使用。</li></ul></li><li><strong>字段</strong><ul><li><strong>接口</strong>：接口中的字段默认是 <code>public static final</code> 的，即常量。它们必须在声明时初始化，且不能被修改。</li><li><strong>抽象类</strong>：抽象类可以包含普通字段(实例变量)，这些字段可以是 <code>public</code>、<code>protected</code> 或 <code>private</code> 的，也可以是静态的或非静态的。</li></ul></li><li><strong>继承和实现</strong><ul><li><strong>接口</strong>：一个类可以实现多个接口。这是实现多继承的一种方式。</li><li><strong>抽象类</strong>：一个类只能继承一个抽象类。如果需要实现多继承，必须通过接口来实现。</li></ul></li><li><strong>构造方法</strong><ul><li><strong>接口</strong>：接口不能有构造方法，因为接口不能被实例化。</li><li><strong>抽象类</strong>：抽象类可以有构造方法，但这些构造方法只能被子类在构造过程中调用。</li></ul></li><li><strong>实例化</strong><ul><li><strong>接口</strong>：接口不能被实例化。</li><li><strong>抽象类</strong>：抽象类也不能被实例化，但可以通过子类来实例化。</li></ul></li></ol><h3 id="三、使用场景"><a href="#三、使用场景" class="headerlink" title="三、使用场景"></a>三、使用场景</h3><ol><li><strong>接口</strong><ul><li>当需要定义一组行为规范，而不需要关心具体的实现细节时，使用接口。例如，定义一个 <code>Animal</code> 接口，其中包含 <code>eat()</code> 和 <code>move()</code> 方法，不同的动物类可以实现这些方法，但具体的实现方式可以不同。</li><li>当<strong>需要实现多继承时</strong>，使用接口。因为 Java 不支持类的多继承，但可以通过实现多个接口来实现类似的效果。</li></ul></li><li><strong>抽象类</strong><ul><li>当需要为一组类提供一个通用的模板，且这些类有一些共同的行为和属性时，使用抽象类。例如，定义一个 <code>Vehicle</code> 抽象类，其中包含 <code>move()</code> 抽象方法和一些通用字段(如 <code>speed</code>、<code>color</code> 等)，然后让 <code>Car</code>、<code>Bike</code> 等子类继承并实现具体的行为。</li><li>当需要在类中提供一些默认实现，同时允许子类根据需要进行扩展时，使用抽象类。</li></ul></li></ol><h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><p>Exception位于<strong>java.lang</strong>包下，它是一种顶级接口，继承于<strong>Throwable</strong>类，<strong>Throwable类是Java语言中所以错误(error)和异常(exception)类的父类</strong>。只有继承于Throwable的类或者其子类才能被抛出，还有一种方式是带有Java中的**@throw**注解的类也可以抛出。</p><p>在Java中，异常(Exception)是一种特殊的对象，用于表示程序运行时出现的错误或异常情况。通过异常处理机制，程序可以在遇到错误时优雅地处理问题，而不是直接崩溃。Java的异常处理机制主要包括异常的抛出(Throw)、捕获(Catch)和处理(Handle)。</p><h3 id="一、异常的分类"><a href="#一、异常的分类" class="headerlink" title="一、异常的分类"></a>一、异常的分类</h3><p>Java中的异常主要分为两大类：<strong>受检查的异常(Checked Exception)和非受检查的异常(Unchecked Exception)</strong>。</p><ol><li><strong>受检查的异常(Checked Exception)</strong><ul><li>这些异常是编译器强制要求处理的异常。它们通常是程序运行时可能出现的外部错误，例如文件找不到(<code>FileNotFoundException</code>)、网络连接失败(<code>IOException</code>)等。</li><li>受检查的异常必须在代码中显式处理，否则编译器会报错。</li><li>受检查的异常继承自<code>Exception</code>类，但不包括<code>RuntimeException</code>及其子类。</li></ul></li><li><strong>非受检查的异常(Unchecked Exception)</strong><ul><li>这些异常是程序逻辑错误或运行时错误，例如空指针异常(<code>NullPointerException</code>)、数组越界异常(<code>ArrayIndexOutOfBoundsException</code>)等。</li><li>非受检查的异常继承自<code>RuntimeException</code>类，编译器不会强制要求处理这些异常。</li><li>但为了程序的健壮性，通常也会对这些异常进行捕获和处理。</li></ul></li><li><strong>错误(Error)</strong><ul><li>错误是程序运行时出现的严重问题，通常是无法恢复的，例如虚拟机错误(<code>VirtualMachineError</code>)、线程死亡(<code>ThreadDeath</code>)等。</li><li>错误继承自<code>Error</code>类，通常不需要程序员处理，因为它们通常表示系统级别的问题。</li></ul></li></ol><h3 id="二、异常处理机制"><a href="#二、异常处理机制" class="headerlink" title="二、异常处理机制"></a>二、异常处理机制</h3><p>Java提供了以下几种机制来处理异常：</p><ol><li><strong>try-catch</strong><ul><li><code>try</code>块用于包裹可能会抛出异常的代码，<code>catch</code>块用于捕获和处理异常。</li><li>可以有多个<code>catch</code>块来捕获不同类型的异常。</li></ul></li><li><strong>finally</strong><ul><li><code>finally</code>块用于在<code>try-catch</code>块执行完毕后执行清理操作，无论是否捕获到异常，<code>finally</code>块都会执行。</li><li>常用于关闭文件流、释放资源等操作。</li></ul></li><li><strong>throw</strong><ul><li><code>throw</code>关键字用于手动抛出一个异常对象，可以是系统定义的异常，也可以是自定义的异常。</li></ul></li><li><strong>throws</strong><ul><li><code>throws</code>关键字用于声明方法可能会抛出的异常。如果方法中可能会抛出受检查的异常，必须在方法签名中声明这些异常。</li></ul></li></ol><h3 id="三、异常处理的流程"><a href="#三、异常处理的流程" class="headerlink" title="三、异常处理的流程"></a>三、异常处理的流程</h3><ol><li><strong>抛出异常</strong><ul><li>当程序运行时遇到错误，会创建一个异常对象并抛出。</li><li>异常对象包含错误信息，例如异常类型、错误消息、堆栈跟踪等。</li></ul></li><li><strong>捕获异常</strong><ul><li>使用<code>try-catch</code>块捕获异常，捕获到异常后可以在<code>catch</code>块中进行处理。</li></ul></li><li><strong>处理异常</strong><ul><li>在<code>catch</code>块中可以记录日志、提示用户、尝试恢复等操作。</li></ul></li><li><strong>清理资源</strong><ul><li>使用<code>finally</code>块进行资源清理，确保资源被正确释放。</li></ul></li></ol><h3 id="四、示例代码"><a href="#四、示例代码" class="headerlink" title="四、示例代码"></a>四、示例代码</h3><p>以下是一个简单的Java异常处理示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 可能会抛出异常的代码</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> divide(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ArithmeticException e) &#123;</span><br><span class="line">            <span class="comment">// 捕获并处理特定类型的异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 捕获其他类型的异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;General Error: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 无论是否捕获到异常，finally块都会执行</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Finally block executed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>(<span class="string">&quot;Division by zero is not allowed.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、自定义异常"><a href="#五、自定义异常" class="headerlink" title="五、自定义异常"></a>五、自定义异常</h3><p>Java允许程序员定义自己的异常类，自定义异常类通常继承自<code>Exception</code>类或其子类。自定义异常可以提供更具体的错误信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCustomException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCustomException</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomExceptionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            checkAge(<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyCustomException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Caught custom exception: &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">checkAge</span><span class="params">(<span class="type">int</span> age)</span> <span class="keyword">throws</span> MyCustomException &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyCustomException</span>(<span class="string">&quot;Age must be at least 18.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Age is valid.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、如何实践"><a href="#六、如何实践" class="headerlink" title="六、如何实践"></a>六、如何实践</h3><ol><li><strong>明确异常的用途</strong><ul><li>受检查的异常用于处理外部错误，非受检查的异常用于处理程序逻辑错误。</li></ul></li><li><strong>合理使用<code>try-catch</code></strong><ul><li>不要捕获所有异常，只捕获需要处理的异常。</li></ul></li><li><strong>避免空的<code>catch</code>块</strong><ul><li>捕获异常后应该进行处理，而不是忽略异常。</li></ul></li><li><strong>使用<code>finally</code>块清理资源</strong><ul><li>确保资源被正确释放，避免资源泄漏。</li></ul></li><li><strong>自定义异常</strong><ul><li>当系统提供的异常类不足以描述错误时，可以定义自定义异常。</li></ul></li></ol><h3 id="七、异常处理的优缺点"><a href="#七、异常处理的优缺点" class="headerlink" title="七、异常处理的优缺点"></a>七、异常处理的优缺点</h3><p><strong>优点</strong></p><ul><li>提高程序的健壮性，避免程序因错误而崩溃。</li><li>提供详细的错误信息，方便调试和修复。</li><li>可以通过异常处理机制实现程序的容错机制。</li></ul><p><strong>缺点</strong></p><ul><li>异常处理机制可能会使代码变得复杂，增加阅读和维护的难度。</li><li>如果滥用异常处理机制，可能会导致程序性能下降。</li></ul><p>总之，合理使用Java的异常处理机制可以提高程序的健壮性和可维护性，但需要谨慎使用，避免滥用。</p><h2 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h2><p>写在一个类里面的类叫内部类。大体分为两种，一种为普通的，一种为静态的。</p><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p><strong>1.实现多继承</strong>，外部类继承一个接口，内部类继承一个接口。而一个外部类可以有多个内部类。</p><p>2.<strong>实现回调机制</strong>，内部类常用于实现事件监听器或其他回调机制。例如，GUI编程中，按钮的事件监听器通常使用匿名内部类实现。</p><p>3.<strong>封装逻辑</strong>，避免暴露具体实现。</p><p>内部类与外部类的其他成员变量，方法等属于同一级，普通的内部类可以直接服务外部类的成员变量和成员方法，静态内部类不可以。</p><p>普通内部类实例化时需要使用外部类.内部类。静态内部类无需。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outer.<span class="keyword">new</span> <span class="title class_">Inner</span>(); <span class="comment">// 创建内部类实例</span></span><br></pre></td></tr></table></figure><p>匿名内部类是直接在实例化时写上该接口的实现，而无需再开一个文件去写实现类。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MyInterface</span> <span class="variable">mi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterface</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Anonymous inner class&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        mi.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="十、集合"><a href="#十、集合" class="headerlink" title="十、集合"></a>十、集合</h2><h3 id="collections框架图"><a href="#collections框架图" class="headerlink" title="collections框架图"></a>collections框架图</h3><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250216221349436.png" alt="image-20250216221349436"></p><h3 id="iterable接口"><a href="#iterable接口" class="headerlink" title="iterable接口"></a>iterable接口</h3><p>定义了一种方法<code>iterator()</code>，允许以统一的方式(增强for)遍历集合。</p><h3 id="顶层接口"><a href="#顶层接口" class="headerlink" title="顶层接口"></a>顶层接口</h3><p><strong>Collection</strong> 是一个顶层接口，它主要用来定义集合的约定<br><strong>List</strong>接口也是一个顶层接口，它继承了 Collection 接口，同时也是ArrayList、LinkedList 等集合元素的父类<br><strong>Set</strong>接口位于与List 接口同级的层次上，它同时也继承了 Collection 接口。Set接口提供了额外的规定。它对add、equals、hashCode方法提供了额外的标准。</p><p><strong>Queue</strong>是和 List、Set接口并列的 Collection的三大接口之一。Queue的设计用来在处理之前保持元素的访问次序。除了Collection基础的操作之外，队列提供了额外的插入，读取，检查操作。</p><p>SortedSet接口直接继承于Set接口，使用 Comparable 对元素进行自然排序或者使用 Comparator在创建时对元素提供定制的排序规则。set的迭代器将按升序元素顺序遍历集合。</p><p>Map是一个支持 key-value存储的对象，Map 不能包含重复的key，每个键最多映射一个值。这个接口代替了Dictionary类，Dictionary是一个抽象类而不是接口。</p><h3 id="类-数据结构"><a href="#类-数据结构" class="headerlink" title="类(数据结构)"></a>类(数据结构)</h3><ol><li><strong>ArrayList</strong>：动态数组实现的列表，支持快速随机访问。</li><li><strong>Vector</strong>：与<code>ArrayList</code>类似，但它是同步的，适用于多线程环境。</li><li><strong>LinkedList 类</strong>：双向链表实现的列表，支持快速插入和删除。</li><li><strong>Stack</strong>：后进先出（LIFO）的栈，基于<code>Vector</code>实现。</li><li><strong>HashSet</strong>：基于哈希表实现的集合，不允许重复元素。</li><li><strong>TreeSet</strong>：基于红黑树实现的有序集合。</li><li><strong>LinkedHashSet 类</strong>：<code>HashSet</code>的链表版本，维护元素插入顺序。</li><li><strong>PriorityQueue</strong>：基于优先级堆实现的队列，元素按自然顺序或构造时指定的比较器排序。</li><li><strong>HashMap</strong>：基于哈希表实现的映射，允许一个null键和多个null值。</li><li><strong>TreeMap 类</strong>：基于红黑树实现的有序映射。</li><li><strong>LinkedHashMap 类</strong>：<code>HashMap</code>的链表版本，维护元素插入或访问顺序。</li><li><strong>Hashtable 类</strong>：与<code>HashMap</code>类似，但它是同步的，适用于多线程环境。</li><li><strong>IdentityHashMap 类</strong>：<code>HashMap</code>的变体，使用引用相等性而不是对象相等性。</li><li><strong>WeakHashMap 类</strong>：键是弱引用的映射，键被垃圾回收时，映射项被自动移除。</li><li><strong>Collections 类</strong>：提供对集合的静态方法操作，如排序、搜索和修改。</li></ol><h3 id="集合实现类特征图"><a href="#集合实现类特征图" class="headerlink" title="集合实现类特征图"></a>集合实现类特征图</h3><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250216222117731.png" alt="image-20250216222117731"></p><h2 id="十一、泛型"><a href="#十一、泛型" class="headerlink" title="十一、泛型"></a>十一、泛型</h2><p>一种语言特性，允许开发者在定义类，接口或方法时使用<strong>类型参数</strong>，从而<strong>提高代码的复用性和灵活性</strong>。泛型的核心思想是将类型抽象化，使得代码可以在不同数据类型上重复使用，同时<strong>保持类型安全</strong>。</p><h3 id="类型参数"><a href="#类型参数" class="headerlink" title="类型参数"></a><strong>类型参数</strong></h3><p>类型参数是泛型的核心，它允许在定义类、接口或方法时指定一个或多个类型占位符。类型参数可以是任何有效的 Java 类型，包括类、接口、数组等。</p><p><strong>类型参数的命名规范</strong></p><ul><li>通常使用单个大写字母表示类型参数，常见的有：<ul><li><code>T</code>（Type）：表示任意类型。</li><li><code>E</code>（Element）：表示集合中的元素类型。</li><li><code>K</code>（Key）：表示键的类型。</li><li><code>V</code>（Value）：表示值的类型。</li><li><code>N</code>（Number）：表示数字类型。</li><li><code>S</code>、<code>U</code>、<code>V</code> 等：用于多个类型参数的区分。</li></ul></li></ul><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a><strong>类型擦除</strong></h3><p>Java泛型会在运行时被擦除，这意味着泛型信息仅在编译时存在，运行时无法获取具体类型。会导致无法创建泛型数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt;[] boxes = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// 编译错误</span></span><br></pre></td></tr></table></figure><p>但是可以通过强制类型转换创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;String&gt;[] boxes = (Box&lt;String&gt;[]) <span class="keyword">new</span> <span class="title class_">Box</span>[<span class="number">10</span>]; <span class="comment">// 需要强制类型转换</span></span><br></pre></td></tr></table></figure><h3 id="类型限制"><a href="#类型限制" class="headerlink" title="类型限制"></a>类型限制</h3><p>1.<strong>不能使用原始数据类型，只能使用包装类</strong></p><p>2.<strong>不能创建泛型的静态字段</strong>，因为静态字段属于类，而泛型类型是实例相关的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> T value; <span class="comment">// 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.<strong>不能实例化泛型类型参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>(); <span class="comment">// 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>通配符（<code>?</code>）用于表示未知类型，分为无界通配符和有界通配符：</p><ol><li><p><strong>无界通配符</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;?&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>表示 <code>Box</code> 的泛型类型是未知的，可以是任何类型。</p></li><li><p><strong>有界通配符</strong>：</p><p>上界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>表示 <code>Box</code> 的泛型类型是 <code>Number</code> 或其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt; objectList = stringList; <span class="comment">// 协变</span></span><br></pre></td></tr></table></figure><p>下界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Box&lt;? <span class="built_in">super</span> Integer&gt; box = <span class="keyword">new</span> <span class="title class_">Box</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>表示 <code>Box</code> 的泛型类型是 <code>Integer</code> 或其父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; objectList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;? <span class="built_in">super</span> String&gt; stringList = objectList; <span class="comment">// 逆变</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="十二、反射"><a href="#十二、反射" class="headerlink" title="十二、反射"></a>十二、反射</h2><p>啥是反射？反射允许对成员变量，成员方法和构造方法的信息进行编程访问。</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250220123104283.png" alt="image-20250220123104283"></p><h3 id="获取对象"><a href="#获取对象" class="headerlink" title="获取对象"></a>获取对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dmw.basedemo.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 获取class对象的三种方式：</span></span><br><span class="line"><span class="comment">        *   1.Class.forName(&quot;全类名&quot;);</span></span><br><span class="line"><span class="comment">        *   2.类名.class</span></span><br><span class="line"><span class="comment">        *   3.对象.getClass();</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        <span class="comment">//全类名：包名+类名</span></span><br><span class="line">        <span class="comment">//最为常用</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.dmw.basedemo.reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种方式</span></span><br><span class="line">        <span class="comment">//一般用于传参</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三种方式</span></span><br><span class="line">        <span class="comment">//当我们已经有了这个类的对象时，才可以使用。</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250220122408100.png" alt="image-20250220122408100"></p><h3 id="获取对象的构造方法"><a href="#获取对象的构造方法" class="headerlink" title="获取对象的构造方法"></a>获取对象的构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dmw.basedemo.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Parameter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2Constructor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Class类中用于获取构造方法的方法</span></span><br><span class="line"><span class="comment">        *   Constructor&lt;?&gt;[] getConstructors()获取公共的构造方法</span></span><br><span class="line"><span class="comment">        *   Constructor&lt;?&gt;[] getDeclaredConstructors()获取所有构造方法</span></span><br><span class="line"><span class="comment">        *   Constructor&lt;?&gt;[] getConstructor(Class&lt;?&gt;...parameterTypes)获取公共的某个构造方法</span></span><br><span class="line"><span class="comment">        *   Constructor&lt;?&gt;[] getConstructors(Class&lt;?&gt;...parameterTypes)获取某个构造方法</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.获取class字节码文件对象</span></span><br><span class="line">        Class clazz= Class.forName(<span class="string">&quot;com.dmw.basedemo.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2获取构造方法</span></span><br><span class="line">        Constructor[] cons = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : cons) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        Constructor[] cons1 = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span>(Constructor c : cons1) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(<span class="type">int</span>.class);</span><br><span class="line">        System.out.println(cons2);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons3</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        System.out.println(cons3);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cons4</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(cons4);</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">Modifiers</span> <span class="operator">=</span> cons4.getModifiers();</span><br><span class="line">        System.out.println(Modifiers);<span class="comment">//其中1为public，2为protected，4为private</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">        <span class="comment">//获取参数</span></span><br><span class="line">        Parameter[] parameters = cons4.getParameters();</span><br><span class="line">        <span class="keyword">for</span>(Parameter p : parameters) &#123;</span><br><span class="line">            System.out.println(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//暴力反射：表示临时取消权限校验</span></span><br><span class="line">        cons4.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//利用获取到的构造方法来构造对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> (Student) cons4.newInstance(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250222225338830.png" alt="image-20250222225338830"></p><p>其中<strong>权限修饰符常量字段值</strong>如下</p><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250222224835797.png"></p><h3 id="获取对象的成员变量"><a href="#获取对象的成员变量" class="headerlink" title="获取对象的成员变量"></a>获取对象的成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dmw.basedemo.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo3Var</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Class类中用于获取成员变量的方法</span></span><br><span class="line"><span class="comment">    * Field[] getFields();//返回所有公共成员变量对象的数组</span></span><br><span class="line"><span class="comment">    * Field[] getDeclaredFieldS();//返回所有成员变量对象的数组</span></span><br><span class="line"><span class="comment">    * Field getField(String name);//返回单个公共成员变量对象</span></span><br><span class="line"><span class="comment">    * Field[] getDeclareField(String name);//返回单个成员变量对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//1.获取class字节码文件对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.dmw.basedemo.reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//2.获取所有的成员变量</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">            System.out.println(field);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取单个的成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">        <span class="comment">//获取权限修饰符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> age.getModifiers();</span><br><span class="line">        System.out.println(modifiers);</span><br><span class="line">        <span class="comment">//获取成员变量的名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">n</span> <span class="operator">=</span> age.getName();</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        <span class="comment">//获取成员变量的类型</span></span><br><span class="line">        Class&lt;?&gt; type = age.getType();</span><br><span class="line">        System.out.println(type);</span><br><span class="line">        <span class="comment">//获取成员变量记录的值</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        age.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> age.get(student);<span class="comment">//获取student这个对象age记录的值</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250223163956807.png" alt="image-20250223163956807"></p><h3 id="获取对象中的成员方法"><a href="#获取对象中的成员方法" class="headerlink" title="获取对象中的成员方法"></a>获取对象中的成员方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Class类中用于获取对象中的成员方法</span></span><br><span class="line"><span class="comment">* Method[] getMethods();//获取当前类及其父类的所有公有方法。</span></span><br><span class="line"><span class="comment">* Method[] getDeclaredMethods()：获取当前类声明的所有方法（包括私有方法）。</span></span><br><span class="line"><span class="comment">* Method getMethod(String name, Class&lt;?&gt;... parameterTypes)：获取公有方法（包括父类方法）</span></span><br><span class="line"><span class="comment">* Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：获取当前类声明的方法（包括私有方法，但不包括父类方法）。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 调用方法</span></span><br><span class="line"><span class="comment">* 通过Method对象，可以使用invoke(Object obj, Object... args)方法调用目标方法。其中：</span></span><br><span class="line"><span class="comment">    obj是目标对象实例。即调用者</span></span><br><span class="line"><span class="comment">    args是方法的参数。</span></span><br><span class="line"><span class="comment">    如果目标方法是静态方法，则obj可以为null。</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure><h3 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h3><p><strong>1.获取一个类里面的所有信息，获取到之后再执行其他的业务逻辑</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.dmw.basedemo.reflect;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">public class Demo5Application &#123;</span><br><span class="line">//获取一个类里面的所有信息，获取到之后再执行其他的业务逻辑(此例子为获取对象的属性值并写入到文件中)</span><br><span class="line">    public static void main(String[] args) throws IOException, IllegalAccessException &#123;</span><br><span class="line">        Student s = new Student(&quot;dmw&quot;,23);</span><br><span class="line">        saveObject(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void saveObject(Object o) throws IOException, IllegalAccessException &#123;</span><br><span class="line">        //1.获取class字节码文件</span><br><span class="line">        Class c = o.getClass();</span><br><span class="line">        //2.创建IO流</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;src\\a.txt&quot;));</span><br><span class="line">        //3.获取所有的成员变量</span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">        for (Field f : fields) &#123;</span><br><span class="line">            f.setAccessible(true);</span><br><span class="line">            String name = f.getName();</span><br><span class="line">            Object value = f.get(o);</span><br><span class="line">            bw.write(name+&quot;:&quot;+value);</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250223191142600.png" alt="image-20250223191142600"></p><p><strong>2.跟配置文件相结合动态的创建对象，并调用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dmw.basedemo.reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo6Application2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//1.读取配置文件的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src/prop.properties&quot;</span>);</span><br><span class="line">        prop.load(fis);</span><br><span class="line">        fis.close();</span><br><span class="line">        System.out.println(prop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.获取全类名和方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> (String) prop.get(<span class="string">&quot;classname&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) prop.get(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        System.out.println(methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.利用反射创建对象并运行方法</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">        <span class="comment">//获取构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(methodName);</span><br><span class="line">        method.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        method.invoke(o);<span class="comment">//利用构造方法创建的对象调用此方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">classname</span>=<span class="string">com.dmw.basedemo.reflect.Student</span></span><br><span class="line"><span class="attr">method</span>=<span class="string">study</span></span><br></pre></td></tr></table></figure><p><img src="/2025/02/04/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E7%9B%98/image-20250223200310462.png" alt="image-20250223200310462"></p><h2 id="十三、枚举"><a href="#十三、枚举" class="headerlink" title="十三、枚举"></a>十三、枚举</h2><h2 id="十四、I-O"><a href="#十四、I-O" class="headerlink" title="十四、I&#x2F;O"></a>十四、I&#x2F;O</h2><h3 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h3><h3 id="2-基础IO类和相关方法"><a href="#2-基础IO类和相关方法" class="headerlink" title="2.基础IO类和相关方法"></a>2.基础IO类和相关方法</h3><h2 id="十五、注解"><a href="#十五、注解" class="headerlink" title="十五、注解"></a>十五、注解</h2><h2 id="十六、关于null的几种处理方式"><a href="#十六、关于null的几种处理方式" class="headerlink" title="十六、关于null的几种处理方式"></a>十六、关于null的几种处理方式</h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于本站</title>
      <link href="/2025/01/29/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/"/>
      <url>/2025/01/29/%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="特别感谢"><a href="#特别感谢" class="headerlink" title="特别感谢"></a>特别感谢</h1><p>本站基于Hexo框架和butterfly主题完成。以下几位是本站建成的引领者和促进者，非常感谢他们的技术分享和支持！(排名不分先后)  </p><ul><li><a href="https://space.bilibili.com/34786453">@康文昌</a></li><li><a href="https://space.bilibili.com/220757832">@Fomalhaut</a></li><li><a href="https://space.bilibili.com/1398826277">@木子dn</a></li><li><a href="https://space.bilibili.com/381992209">@阿巴In</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2025/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2025/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="测试文章"><a href="#测试文章" class="headerlink" title="测试文章"></a>测试文章</h1><p>是否正常显示  </p><h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><h2 id="这是一个二级标题"><a href="#这是一个二级标题" class="headerlink" title="这是一个二级标题"></a>这是一个二级标题</h2><p>这是一个段落文本。可以包含 <strong>加粗文本</strong>、<em>斜体文本</em> 和 <a href="https://blog.csdn.net/qq_73995047?type=blog">链接</a>。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><ul><li>项目 1</li><li>项目 2<ul><li>子项目 2.1</li></ul></li><li>项目 3</li></ul><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="/2025/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/logo.jpg" alt="示例图片" title="logo"></p>]]></content>
      
      
      <categories>
          
          <category> 博客相关 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
